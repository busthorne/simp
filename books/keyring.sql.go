// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: keyring.sql

package books

import (
	"context"
)

const keyringDelete = `-- name: KeyringDelete :exec
delete from keyring
	where ring = ? and ns = ? and key = ?
`

type KeyringDeleteParams struct {
	Ring string `db:"ring" json:"ring"`
	Ns   string `db:"ns" json:"ns"`
	Key  string `db:"key" json:"key"`
}

func (q *Queries) KeyringDelete(ctx context.Context, arg KeyringDeleteParams) error {
	_, err := q.db.ExecContext(ctx, keyringDelete, arg.Ring, arg.Ns, arg.Key)
	return err
}

const keyringGet = `-- name: KeyringGet :one
select value
	from keyring
	where ring = ? and ns = ? and key = ?
`

type KeyringGetParams struct {
	Ring string `db:"ring" json:"ring"`
	Ns   string `db:"ns" json:"ns"`
	Key  string `db:"key" json:"key"`
}

func (q *Queries) KeyringGet(ctx context.Context, arg KeyringGetParams) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, keyringGet, arg.Ring, arg.Ns, arg.Key)
	var value []byte
	err := row.Scan(&value)
	return value, err
}

const keyringList = `-- name: KeyringList :many
select key
	from keyring
	where ring = ? and ns = ?
`

type KeyringListParams struct {
	Ring string `db:"ring" json:"ring"`
	Ns   string `db:"ns" json:"ns"`
}

func (q *Queries) KeyringList(ctx context.Context, arg KeyringListParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, keyringList, arg.Ring, arg.Ns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var key string
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const keyringSet = `-- name: KeyringSet :exec
insert into keyring (ring, ns, key, value, updated_at)
	values (?, ?, ?, ?, current_timestamp)
	on conflict (ring, ns, key)
		do update set
			value = excluded.value,
			updated_at = current_timestamp
`

type KeyringSetParams struct {
	Ring  string `db:"ring" json:"ring"`
	Ns    string `db:"ns" json:"ns"`
	Key   string `db:"key" json:"key"`
	Value []byte `db:"value" json:"value"`
}

func (q *Queries) KeyringSet(ctx context.Context, arg KeyringSetParams) error {
	_, err := q.db.ExecContext(ctx, keyringSet,
		arg.Ring,
		arg.Ns,
		arg.Key,
		arg.Value,
	)
	return err
}
