// Code generated by genvertex; DO NOT EDIT.
package vertexjson

import (
	"cloud.google.com/go/civil"
	"cloud.google.com/go/vertexai/genai"
	"time" // Needed for types like CachedContent and ExpireTimeOrTTL
	// Add necessary imports based on build errors
	// aiplatform "google.golang.org/genproto/googleapis/cloud/aiplatform/v1beta1" // Removed - Not used
	// "google.golang.org/protobuf/proto" // Removed - Not used
)

// Define enum types to match genai package
type FinishReason int32        // Use underlying type
type FunctionCallingMode int32 // Use underlying type
type HarmCategory int32        // Use underlying type
type HarmBlockThreshold int32  // Use underlying type (Corrected from string)
type HarmProbability int32     // Use underlying type
type HarmSeverity int32        // Use underlying type
type Type int32
type BlockedReason int32    // Use underlying type
type HarmBlockMethod string // Keep as string for now unless errors show otherwise

// Helper type for ExpireTimeOrTTL which is a union type
type ExpireTimeOrTTL struct {
	// Only one of these should be set
	ExpireTime time.Time     `json:"expireTime,omitempty"`
	TTL        time.Duration `json:"ttl,omitempty"`
}

// FromExpireTimeOrTTL converts from genai.ExpireTimeOrTTL to ExpireTimeOrTTL
func FromExpireTimeOrTTL(src genai.ExpireTimeOrTTL) ExpireTimeOrTTL {
	var result ExpireTimeOrTTL

	if src.TTL != 0 {
		result.TTL = src.TTL
	} else if !src.ExpireTime.IsZero() {
		result.ExpireTime = src.ExpireTime
	}

	return result
}

// To converts to genai.ExpireTimeOrTTL
func (e ExpireTimeOrTTL) To() genai.ExpireTimeOrTTL {
	var result genai.ExpireTimeOrTTL

	if e.TTL != 0 {
		result.TTL = e.TTL
	} else if !e.ExpireTime.IsZero() {
		result.ExpireTime = e.ExpireTime
	}

	return result
}

// Part is an interface in genai, so we need custom types and handling
type Part struct {
	// Only one of these fields should be set
	Text             string            `json:"text,omitempty"`
	FunctionCall     *FunctionCall     `json:"functionCall,omitempty"`
	FunctionResponse *FunctionResponse `json:"functionResponse,omitempty"`
	FileData         *FileData         `json:"fileData,omitempty"`
	Blob             *Blob             `json:"blob,omitempty"`
}

// FromPart converts from genai.Part to Part
func FromPart(src genai.Part) Part {
	var p Part

	switch v := src.(type) {
	case genai.Text:
		p.Text = string(v)
	case *genai.FunctionCall:
		p.FunctionCall = FromFunctionCall(v)
	case *genai.FunctionResponse:
		p.FunctionResponse = FromFunctionResponse(v)
	case *genai.FileData:
		p.FileData = FromFileData(v)
	case *genai.Blob:
		p.Blob = FromBlob(v)
	}

	return p
}

// To converts to genai.Part
func (p Part) To() genai.Part {
	switch {
	case p.Text != "":
		return genai.Text(p.Text)
	case p.FunctionCall != nil:
		return p.FunctionCall.To()
	case p.FunctionResponse != nil:
		return p.FunctionResponse.To()
	case p.FileData != nil:
		return p.FileData.To()
	case p.Blob != nil:
		return p.Blob.To()
	default:
		// Return nil or an empty part? Returning nil might be problematic if the slice expects non-nil parts.
		// Let's return an empty Text part for now, consistent with original FromPart logic if no type matched.
		return genai.Text("")
	}
}

// FromPartSlice converts a slice of genai.Part to a slice of Part
func FromPartSlice(src []genai.Part) []Part {
	if src == nil {
		// Return nil instead of empty slice to distinguish between unset and empty
		return nil
	}
	result := make([]Part, len(src))
	for i, v := range src {
		result[i] = FromPart(v) // FromPart handles the conversion of individual Part types
	}
	return result
}

// ToPartSlice converts a slice of Part to a slice of genai.Part
func ToPartSlice(src []Part) []genai.Part {
	if src == nil {
		// Return nil instead of empty slice
		return nil
	}
	result := make([]genai.Part, len(src))
	for i, v := range src {
		result[i] = v.To() // v.To() handles the conversion back to genai.Part types
	}
	return result
}

// Blob mirrors genai.Blob with JSON tags.
// Blob contains binary data like images. Use [Text] for text.
type Blob struct {
	MIMEType string `json:"mIMEType,omitempty"` // Use target type (potentially unqualified)
	Data     []byte `json:"data,omitempty"`     // Use target type (potentially unqualified)
}

// FromBlob converts from genai.Blob to Blob
func FromBlob(src *genai.Blob) *Blob {
	if src == nil {
		return nil
	}
	return &Blob{

		MIMEType: src.MIMEType,

		Data: src.Data,
	}
}

// To converts to genai.Blob
func (j *Blob) To() *genai.Blob {
	if j == nil {
		return nil
	}
	return &genai.Blob{

		MIMEType: j.MIMEType,

		Data: j.Data,
	}
}

// CachedContent mirrors genai.CachedContent with JSON tags.
// CachedContent is a resource used in LLM queries for users to explicitly specify what to cache and how to cache.
type CachedContent struct {
	Expiration        ExpireTimeOrTTL `json:"expiration,omitempty"`        // Use target type (potentially unqualified)
	Name              string          `json:"name,omitempty"`              // Use target type (potentially unqualified)
	Model             string          `json:"model,omitempty"`             // Use target type (potentially unqualified)
	SystemInstruction *Content        `json:"systemInstruction,omitempty"` // Use target type (potentially unqualified)
	Contents          []*Content      `json:"contents,omitempty"`          // Use target type (potentially unqualified)
	Tools             []*Tool         `json:"tools,omitempty"`             // Use target type (potentially unqualified)
	ToolConfig        *ToolConfig     `json:"toolConfig,omitempty"`        // Use target type (potentially unqualified)
	CreateTime        time.Time       `json:"createTime,omitempty"`        // Use target type (potentially unqualified)
	UpdateTime        time.Time       `json:"updateTime,omitempty"`        // Use target type (potentially unqualified)
}

// FromCachedContent converts from genai.CachedContent to CachedContent
func FromCachedContent(src *genai.CachedContent) *CachedContent {
	if src == nil {
		return nil
	}
	return &CachedContent{

		Expiration: FromExpireTimeOrTTL(src.Expiration),

		Name: src.Name,

		Model: src.Model,

		SystemInstruction: FromContent(src.SystemInstruction),

		Contents: FromContentSlice(src.Contents),

		Tools: FromToolSlice(src.Tools),

		ToolConfig: FromToolConfig(src.ToolConfig),

		CreateTime: src.CreateTime,

		UpdateTime: src.UpdateTime,
	}
}

// To converts to genai.CachedContent
func (j *CachedContent) To() *genai.CachedContent {
	if j == nil {
		return nil
	}
	return &genai.CachedContent{

		Expiration: j.Expiration.To(), // ExpireTimeOrTTL conversion

		Name: j.Name,

		Model: j.Model,

		SystemInstruction: j.SystemInstruction.To(), // Assumes Content has To() method

		Contents: ToContentSlice(j.Contents),

		Tools: ToToolSlice(j.Tools),

		ToolConfig: j.ToolConfig.To(), // Assumes ToolConfig has To() method

		CreateTime: j.CreateTime,

		UpdateTime: j.UpdateTime,
	}
}

// Candidate mirrors genai.Candidate with JSON tags.
// Candidate is a response candidate generated from the model.
type Candidate struct {
	Index            int32             `json:"index,omitempty"`            // Use target type (potentially unqualified)
	Content          *Content          `json:"content,omitempty"`          // Use target type (potentially unqualified)
	FinishReason     FinishReason      `json:"finishReason,omitempty"`     // Use target type (potentially unqualified)
	SafetyRatings    []*SafetyRating   `json:"safetyRatings,omitempty"`    // Use target type (potentially unqualified)
	FinishMessage    string            `json:"finishMessage,omitempty"`    // Use target type (potentially unqualified)
	CitationMetadata *CitationMetadata `json:"citationMetadata,omitempty"` // Use target type (potentially unqualified)
}

// FromCandidate converts from genai.Candidate to Candidate
func FromCandidate(src *genai.Candidate) *Candidate {
	if src == nil {
		return nil
	}
	return &Candidate{

		Index: src.Index,

		Content: FromContent(src.Content),

		FinishReason: FinishReason(src.FinishReason),

		SafetyRatings: FromSafetyRatingSlice(src.SafetyRatings),

		FinishMessage: src.FinishMessage,

		CitationMetadata: FromCitationMetadata(src.CitationMetadata),
	}
}

// To converts to genai.Candidate
func (j *Candidate) To() *genai.Candidate {
	if j == nil {
		return nil
	}
	return &genai.Candidate{

		Index: j.Index,

		Content: j.Content.To(), // Assumes Content has To() method

		FinishReason: genai.FinishReason(j.FinishReason),

		SafetyRatings: ToSafetyRatingSlice(j.SafetyRatings),

		FinishMessage: j.FinishMessage,

		CitationMetadata: j.CitationMetadata.To(), // Assumes CitationMetadata has To() method
	}
}

// Citation mirrors genai.Citation with JSON tags.
// Citation contains source attributions for content.
type Citation struct {
	StartIndex      int32      `json:"startIndex,omitempty"`      // Use target type (potentially unqualified)
	EndIndex        int32      `json:"endIndex,omitempty"`        // Use target type (potentially unqualified)
	URI             string     `json:"uRI,omitempty"`             // Use target type (potentially unqualified)
	Title           string     `json:"title,omitempty"`           // Use target type (potentially unqualified)
	License         string     `json:"license,omitempty"`         // Use target type (potentially unqualified)
	PublicationDate civil.Date `json:"publicationDate,omitempty"` // Use target type (potentially unqualified)
}

// FromCitation converts from genai.Citation to Citation
func FromCitation(src *genai.Citation) *Citation {
	if src == nil {
		return nil
	}
	return &Citation{

		StartIndex: src.StartIndex,

		EndIndex: src.EndIndex,

		URI: src.URI,

		Title: src.Title,

		License: src.License,

		PublicationDate: src.PublicationDate,
	}
}

// To converts to genai.Citation
func (j *Citation) To() *genai.Citation {
	if j == nil {
		return nil
	}
	return &genai.Citation{

		StartIndex: j.StartIndex,

		EndIndex: j.EndIndex,

		URI: j.URI,

		Title: j.Title,

		License: j.License,

		PublicationDate: j.PublicationDate,
	}
}

// CitationMetadata mirrors genai.CitationMetadata with JSON tags.
// CitationMetadata is a collection of source attributions for a piece of content.
type CitationMetadata struct {
	Citations []*Citation `json:"citations,omitempty"` // Use target type (potentially unqualified)
}

// FromCitationMetadata converts from genai.CitationMetadata to CitationMetadata
func FromCitationMetadata(src *genai.CitationMetadata) *CitationMetadata {
	if src == nil {
		return nil
	}
	return &CitationMetadata{

		Citations: FromCitationSlice(src.Citations),
	}
}

// To converts to genai.CitationMetadata
func (j *CitationMetadata) To() *genai.CitationMetadata {
	if j == nil {
		return nil
	}
	return &genai.CitationMetadata{

		Citations: ToCitationSlice(j.Citations),
	}
}

// Content mirrors genai.Content with JSON tags.
// Content is the base structured datatype containing multi-part content of a message. A `Content` includes a `role` field designating the producer of the `Content` and a `parts` field containing multi-part data that contains the content of the message turn.
type Content struct {
	Role  string `json:"role,omitempty"`  // Use target type (potentially unqualified)
	Parts []Part `json:"parts,omitempty"` // Use target type (potentially unqualified)
}

// FromContent converts from genai.Content to Content
func FromContent(src *genai.Content) *Content {
	if src == nil {
		return nil
	}
	return &Content{

		Role: src.Role,

		Parts: FromPartSlice(src.Parts),
	}
}

// To converts to genai.Content
func (j *Content) To() *genai.Content {
	if j == nil {
		return nil
	}
	return &genai.Content{

		Role: j.Role,

		Parts: ToPartSlice(j.Parts),
	}
}

// CountTokensResponse mirrors genai.CountTokensResponse with JSON tags.
// CountTokensResponse is response message for [PredictionService.CountTokens][google.cloud.aiplatform.v1beta1.PredictionService.CountTokens].
type CountTokensResponse struct {
	TotalTokens             int32 `json:"totalTokens,omitempty"`             // Use target type (potentially unqualified)
	TotalBillableCharacters int32 `json:"totalBillableCharacters,omitempty"` // Use target type (potentially unqualified)
}

// FromCountTokensResponse converts from genai.CountTokensResponse to CountTokensResponse
func FromCountTokensResponse(src *genai.CountTokensResponse) *CountTokensResponse {
	if src == nil {
		return nil
	}
	return &CountTokensResponse{

		TotalTokens: src.TotalTokens,

		TotalBillableCharacters: src.TotalBillableCharacters,
	}
}

// To converts to genai.CountTokensResponse
func (j *CountTokensResponse) To() *genai.CountTokensResponse {
	if j == nil {
		return nil
	}
	return &genai.CountTokensResponse{

		TotalTokens: j.TotalTokens,

		TotalBillableCharacters: j.TotalBillableCharacters,
	}
}

// FileData mirrors genai.FileData with JSON tags.
// FileData is URI based data.
type FileData struct {
	MIMEType string `json:"mIMEType,omitempty"` // Use target type (potentially unqualified)
	FileURI  string `json:"fileURI,omitempty"`  // Use target type (potentially unqualified)
}

// FromFileData converts from genai.FileData to FileData
func FromFileData(src *genai.FileData) *FileData {
	if src == nil {
		return nil
	}
	return &FileData{

		MIMEType: src.MIMEType,

		FileURI: src.FileURI,
	}
}

// To converts to genai.FileData
func (j *FileData) To() *genai.FileData {
	if j == nil {
		return nil
	}
	return &genai.FileData{

		MIMEType: j.MIMEType,

		FileURI: j.FileURI,
	}
}

// FunctionCall mirrors genai.FunctionCall with JSON tags.
// FunctionCall is a predicted [FunctionCall] returned from the model that contains a string representing the [FunctionDeclaration.name] and a structured JSON object containing the parameters and their values.
type FunctionCall struct {
	Name string         `json:"name,omitempty"` // Use target type (potentially unqualified)
	Args map[string]any `json:"args,omitempty"` // Use target type (potentially unqualified)
}

// FromFunctionCall converts from genai.FunctionCall to FunctionCall
func FromFunctionCall(src *genai.FunctionCall) *FunctionCall {
	if src == nil {
		return nil
	}
	return &FunctionCall{

		Name: src.Name,

		Args: src.Args,
	}
}

// To converts to genai.FunctionCall
func (j *FunctionCall) To() *genai.FunctionCall {
	if j == nil {
		return nil
	}
	return &genai.FunctionCall{

		Name: j.Name,

		Args: j.Args,
	}
}

// FunctionCallingConfig mirrors genai.FunctionCallingConfig with JSON tags.
// FunctionCallingConfig holds configuration for function calling.
type FunctionCallingConfig struct {
	Mode                 FunctionCallingMode `json:"mode,omitempty"`                 // Use target type (potentially unqualified)
	AllowedFunctionNames []string            `json:"allowedFunctionNames,omitempty"` // Use target type (potentially unqualified)
}

// FromFunctionCallingConfig converts from genai.FunctionCallingConfig to FunctionCallingConfig
func FromFunctionCallingConfig(src *genai.FunctionCallingConfig) *FunctionCallingConfig {
	if src == nil {
		return nil
	}
	return &FunctionCallingConfig{

		Mode: FunctionCallingMode(src.Mode),

		AllowedFunctionNames: src.AllowedFunctionNames,
	}
}

// To converts to genai.FunctionCallingConfig
func (j *FunctionCallingConfig) To() *genai.FunctionCallingConfig {
	if j == nil {
		return nil
	}
	return &genai.FunctionCallingConfig{

		Mode: genai.FunctionCallingMode(j.Mode),

		AllowedFunctionNames: j.AllowedFunctionNames,
	}
}

// FunctionDeclaration mirrors genai.FunctionDeclaration with JSON tags.
// FunctionDeclaration is structured representation of a function declaration as defined by the [OpenAPI 3.0 specification](https://spec.openapis.org/oas/v3.0.3). Included in this declaration are the function name and parameters. This FunctionDeclaration is a representation of a block of code that can be used as a `Tool` by the model and executed by the client.
type FunctionDeclaration struct {
	Name        string  `json:"name,omitempty"`        // Use target type (potentially unqualified)
	Description string  `json:"description,omitempty"` // Use target type (potentially unqualified)
	Parameters  *Schema `json:"parameters,omitempty"`  // Use target type (potentially unqualified)
	Response    *Schema `json:"response,omitempty"`    // Use target type (potentially unqualified)
}

// FromFunctionDeclaration converts from genai.FunctionDeclaration to FunctionDeclaration
func FromFunctionDeclaration(src *genai.FunctionDeclaration) *FunctionDeclaration {
	if src == nil {
		return nil
	}
	return &FunctionDeclaration{

		Name: src.Name,

		Description: src.Description,

		Parameters: FromSchema(src.Parameters),

		Response: FromSchema(src.Response),
	}
}

// To converts to genai.FunctionDeclaration
func (j *FunctionDeclaration) To() *genai.FunctionDeclaration {
	if j == nil {
		return nil
	}
	return &genai.FunctionDeclaration{

		Name: j.Name,

		Description: j.Description,

		Parameters: j.Parameters.To(), // Assumes Schema has To() method

		Response: j.Response.To(), // Assumes Schema has To() method
	}
}

// FunctionResponse mirrors genai.FunctionResponse with JSON tags.
// FunctionResponse is the result output from a [FunctionCall] that contains a string representing the [FunctionDeclaration.name] and a structured JSON object containing any output from the function is used as context to the model. This should contain the result of a [FunctionCall] made based on model prediction.
type FunctionResponse struct {
	Name     string         `json:"name,omitempty"`     // Use target type (potentially unqualified)
	Response map[string]any `json:"response,omitempty"` // Use target type (potentially unqualified)
}

// FromFunctionResponse converts from genai.FunctionResponse to FunctionResponse
func FromFunctionResponse(src *genai.FunctionResponse) *FunctionResponse {
	if src == nil {
		return nil
	}
	return &FunctionResponse{

		Name: src.Name,

		Response: src.Response,
	}
}

// To converts to genai.FunctionResponse
func (j *FunctionResponse) To() *genai.FunctionResponse {
	if j == nil {
		return nil
	}
	return &genai.FunctionResponse{

		Name: j.Name,

		Response: j.Response,
	}
}

// GenerateContentResponse mirrors genai.GenerateContentResponse with JSON tags.
// GenerateContentResponse is the response from a GenerateContent or GenerateContentStream call.
type GenerateContentResponse struct {
	Candidates     []*Candidate    `json:"candidates,omitempty"`     // Use target type (potentially unqualified)
	PromptFeedback *PromptFeedback `json:"promptFeedback,omitempty"` // Use target type (potentially unqualified)
	UsageMetadata  *UsageMetadata  `json:"usageMetadata,omitempty"`  // Use target type (potentially unqualified)
}

// FromGenerateContentResponse converts from genai.GenerateContentResponse to GenerateContentResponse
func FromGenerateContentResponse(src *genai.GenerateContentResponse) *GenerateContentResponse {
	if src == nil {
		return nil
	}
	return &GenerateContentResponse{

		Candidates: FromCandidateSlice(src.Candidates),

		PromptFeedback: FromPromptFeedback(src.PromptFeedback),

		UsageMetadata: FromUsageMetadata(src.UsageMetadata),
	}
}

// To converts to genai.GenerateContentResponse
func (j *GenerateContentResponse) To() *genai.GenerateContentResponse {
	if j == nil {
		return nil
	}
	return &genai.GenerateContentResponse{

		Candidates: ToCandidateSlice(j.Candidates),

		PromptFeedback: j.PromptFeedback.To(), // Assumes PromptFeedback has To() method

		UsageMetadata: j.UsageMetadata.To(), // Assumes UsageMetadata has To() method
	}
}

// GenerationConfig mirrors genai.GenerationConfig with JSON tags.
// GenerationConfig is generation config.
type GenerationConfig struct {
	Temperature      *float32 `json:"temperature,omitempty"`      // Use target type (potentially unqualified)
	TopP             *float32 `json:"topP,omitempty"`             // Use target type (potentially unqualified)
	TopK             *int32   `json:"topK,omitempty"`             // Use target type (potentially unqualified)
	CandidateCount   *int32   `json:"candidateCount,omitempty"`   // Use target type (potentially unqualified)
	MaxOutputTokens  *int32   `json:"maxOutputTokens,omitempty"`  // Use target type (potentially unqualified)
	StopSequences    []string `json:"stopSequences,omitempty"`    // Use target type (potentially unqualified)
	PresencePenalty  *float32 `json:"presencePenalty,omitempty"`  // Use target type (potentially unqualified)
	FrequencyPenalty *float32 `json:"frequencyPenalty,omitempty"` // Use target type (potentially unqualified)
	ResponseMIMEType string   `json:"responseMIMEType,omitempty"` // Use target type (potentially unqualified)
	ResponseSchema   *Schema  `json:"responseSchema,omitempty"`   // Use target type (potentially unqualified)
}

// FromGenerationConfig converts from genai.GenerationConfig to GenerationConfig
func FromGenerationConfig(src *genai.GenerationConfig) *GenerationConfig {
	if src == nil {
		return nil
	}
	return &GenerationConfig{

		Temperature: src.Temperature,

		TopP: src.TopP,

		TopK: src.TopK,

		CandidateCount: src.CandidateCount,

		MaxOutputTokens: src.MaxOutputTokens,

		StopSequences: src.StopSequences,

		PresencePenalty: src.PresencePenalty,

		FrequencyPenalty: src.FrequencyPenalty,

		ResponseMIMEType: src.ResponseMIMEType,

		ResponseSchema: FromSchema(src.ResponseSchema),
	}
}

// To converts to genai.GenerationConfig
func (j *GenerationConfig) To() *genai.GenerationConfig {
	if j == nil {
		return nil
	}
	return &genai.GenerationConfig{

		Temperature: j.Temperature,

		TopP: j.TopP,

		TopK: j.TopK,

		CandidateCount: j.CandidateCount,

		MaxOutputTokens: j.MaxOutputTokens,

		StopSequences: j.StopSequences,

		PresencePenalty: j.PresencePenalty,

		FrequencyPenalty: j.FrequencyPenalty,

		ResponseMIMEType: j.ResponseMIMEType,

		ResponseSchema: j.ResponseSchema.To(), // Assumes Schema has To() method
	}
}

// PromptFeedback mirrors genai.PromptFeedback with JSON tags.
// PromptFeedback contains content filter results for a prompt sent in the request.
type PromptFeedback struct {
	BlockReason        BlockedReason   `json:"blockReason,omitempty"`        // Use target type (potentially unqualified)
	SafetyRatings      []*SafetyRating `json:"safetyRatings,omitempty"`      // Use target type (potentially unqualified)
	BlockReasonMessage string          `json:"blockReasonMessage,omitempty"` // Use target type (potentially unqualified)
}

// FromPromptFeedback converts from genai.PromptFeedback to PromptFeedback
func FromPromptFeedback(src *genai.PromptFeedback) *PromptFeedback {
	if src == nil {
		return nil
	}
	return &PromptFeedback{

		BlockReason: BlockedReason(src.BlockReason),

		SafetyRatings: FromSafetyRatingSlice(src.SafetyRatings),

		BlockReasonMessage: src.BlockReasonMessage,
	}
}

// To converts to genai.PromptFeedback
func (j *PromptFeedback) To() *genai.PromptFeedback {
	if j == nil {
		return nil
	}
	return &genai.PromptFeedback{

		BlockReason: genai.BlockedReason(j.BlockReason),

		SafetyRatings: ToSafetyRatingSlice(j.SafetyRatings),

		BlockReasonMessage: j.BlockReasonMessage,
	}
}

// SafetyRating mirrors genai.SafetyRating with JSON tags.
// SafetyRating is the safety rating corresponding to the generated content.
type SafetyRating struct {
	Category         HarmCategory    `json:"category,omitempty"`         // Use target type (potentially unqualified)
	Probability      HarmProbability `json:"probability,omitempty"`      // Use target type (potentially unqualified)
	ProbabilityScore float32         `json:"probabilityScore,omitempty"` // Use target type (potentially unqualified)
	Severity         HarmSeverity    `json:"severity,omitempty"`         // Use target type (potentially unqualified)
	SeverityScore    float32         `json:"severityScore,omitempty"`    // Use target type (potentially unqualified)
	Blocked          bool            `json:"blocked,omitempty"`          // Use target type (potentially unqualified)
}

// FromSafetyRating converts from genai.SafetyRating to SafetyRating
func FromSafetyRating(src *genai.SafetyRating) *SafetyRating {
	if src == nil {
		return nil
	}
	return &SafetyRating{

		Category: HarmCategory(src.Category),

		Probability: HarmProbability(src.Probability),

		ProbabilityScore: src.ProbabilityScore,

		Severity: HarmSeverity(src.Severity),

		SeverityScore: src.SeverityScore,

		Blocked: src.Blocked,
	}
}

// To converts to genai.SafetyRating
func (j *SafetyRating) To() *genai.SafetyRating {
	if j == nil {
		return nil
	}
	return &genai.SafetyRating{

		Category: genai.HarmCategory(j.Category),

		Probability: genai.HarmProbability(j.Probability),

		ProbabilityScore: j.ProbabilityScore,

		Severity: genai.HarmSeverity(j.Severity),

		SeverityScore: j.SeverityScore,

		Blocked: j.Blocked,
	}
}

// Schema mirrors genai.Schema with JSON tags.
// Schema is used to define the format of input/output data. Represents a select subset of an [OpenAPI 3.0 schema object](https://spec.openapis.org/oas/v3.0.3#schema). More fields may be added in the future as needed.
type Schema struct {
	Type          Type               `json:"type,omitempty"`          // Use target type (potentially unqualified)
	Format        string             `json:"format,omitempty"`        // Use target type (potentially unqualified)
	Title         string             `json:"title,omitempty"`         // Use target type (potentially unqualified)
	Description   string             `json:"description,omitempty"`   // Use target type (potentially unqualified)
	Nullable      bool               `json:"nullable,omitempty"`      // Use target type (potentially unqualified)
	Items         *Schema            `json:"items,omitempty"`         // Use target type (potentially unqualified)
	MinItems      int64              `json:"minItems,omitempty"`      // Use target type (potentially unqualified)
	MaxItems      int64              `json:"maxItems,omitempty"`      // Use target type (potentially unqualified)
	Enum          []string           `json:"enum,omitempty"`          // Use target type (potentially unqualified)
	Properties    map[string]*Schema `json:"properties,omitempty"`    // Use target type (potentially unqualified)
	Required      []string           `json:"required,omitempty"`      // Use target type (potentially unqualified)
	MinProperties int64              `json:"minProperties,omitempty"` // Use target type (potentially unqualified)
	MaxProperties int64              `json:"maxProperties,omitempty"` // Use target type (potentially unqualified)
	Minimum       float64            `json:"minimum,omitempty"`       // Use target type (potentially unqualified)
	Maximum       float64            `json:"maximum,omitempty"`       // Use target type (potentially unqualified)
	MinLength     int64              `json:"minLength,omitempty"`     // Use target type (potentially unqualified)
	MaxLength     int64              `json:"maxLength,omitempty"`     // Use target type (potentially unqualified)
	Pattern       string             `json:"pattern,omitempty"`       // Use target type (potentially unqualified)
}

// FromSchema converts from genai.Schema to Schema
func FromSchema(src *genai.Schema) *Schema {
	if src == nil {
		return nil
	}
	return &Schema{

		Type: Type(src.Type),

		Format: src.Format,

		Title: src.Title,

		Description: src.Description,

		Nullable: src.Nullable,

		Items: FromSchema(src.Items),

		MinItems: src.MinItems,

		MaxItems: src.MaxItems,

		Enum: src.Enum,

		Properties: FromSchemaMap(src.Properties),

		Required: src.Required,

		MinProperties: src.MinProperties,

		MaxProperties: src.MaxProperties,

		Minimum: src.Minimum,

		Maximum: src.Maximum,

		MinLength: src.MinLength,

		MaxLength: src.MaxLength,

		Pattern: src.Pattern,
	}
}

// To converts to genai.Schema
func (j *Schema) To() *genai.Schema {
	if j == nil {
		return nil
	}
	return &genai.Schema{

		Type: genai.Type(j.Type),

		Format: j.Format,

		Title: j.Title,

		Description: j.Description,

		Nullable: j.Nullable,

		Items: j.Items.To(), // Assumes Schema has To() method

		MinItems: j.MinItems,

		MaxItems: j.MaxItems,

		Enum: j.Enum,

		Properties: ToSchemaMap(j.Properties),

		Required: j.Required,

		MinProperties: j.MinProperties,

		MaxProperties: j.MaxProperties,

		Minimum: j.Minimum,

		Maximum: j.Maximum,

		MinLength: j.MinLength,

		MaxLength: j.MaxLength,

		Pattern: j.Pattern,
	}
}

// Tool mirrors genai.Tool with JSON tags.
// Tool details that the model may use to generate response. A `Tool` is a piece of code that enables the system to interact with external systems to perform an action, or set of actions, outside of knowledge and scope of the model. A Tool object should contain exactly one type of Tool (e.g FunctionDeclaration, Retrieval or GoogleSearchRetrieval).
type Tool struct {
	FunctionDeclarations []*FunctionDeclaration `json:"functionDeclarations,omitempty"` // Use target type (potentially unqualified)
}

// FromTool converts from genai.Tool to Tool
func FromTool(src *genai.Tool) *Tool {
	if src == nil {
		return nil
	}
	return &Tool{

		FunctionDeclarations: FromFunctionDeclarationSlice(src.FunctionDeclarations),
	}
}

// To converts to genai.Tool
func (j *Tool) To() *genai.Tool {
	if j == nil {
		return nil
	}
	return &genai.Tool{

		FunctionDeclarations: ToFunctionDeclarationSlice(j.FunctionDeclarations),
	}
}

// ToolConfig mirrors genai.ToolConfig with JSON tags.
// ToolConfig configures tools.
type ToolConfig struct {
	FunctionCallingConfig *FunctionCallingConfig `json:"functionCallingConfig,omitempty"` // Use target type (potentially unqualified)
}

// FromToolConfig converts from genai.ToolConfig to ToolConfig
func FromToolConfig(src *genai.ToolConfig) *ToolConfig {
	if src == nil {
		return nil
	}
	return &ToolConfig{

		FunctionCallingConfig: FromFunctionCallingConfig(src.FunctionCallingConfig),
	}
}

// To converts to genai.ToolConfig
func (j *ToolConfig) To() *genai.ToolConfig {
	if j == nil {
		return nil
	}
	return &genai.ToolConfig{

		FunctionCallingConfig: j.FunctionCallingConfig.To(), // Assumes FunctionCallingConfig has To() method
	}
}

// UsageMetadata mirrors genai.UsageMetadata with JSON tags.
// UsageMetadata is usage metadata about response(s).
type UsageMetadata struct {
	PromptTokenCount     int32 `json:"promptTokenCount,omitempty"`     // Use target type (potentially unqualified)
	CandidatesTokenCount int32 `json:"candidatesTokenCount,omitempty"` // Use target type (potentially unqualified)
	TotalTokenCount      int32 `json:"totalTokenCount,omitempty"`      // Use target type (potentially unqualified)
}

// FromUsageMetadata converts from genai.UsageMetadata to UsageMetadata
func FromUsageMetadata(src *genai.UsageMetadata) *UsageMetadata {
	if src == nil {
		return nil
	}
	return &UsageMetadata{

		PromptTokenCount: src.PromptTokenCount,

		CandidatesTokenCount: src.CandidatesTokenCount,

		TotalTokenCount: src.TotalTokenCount,
	}
}

// To converts to genai.UsageMetadata
func (j *UsageMetadata) To() *genai.UsageMetadata {
	if j == nil {
		return nil
	}
	return &genai.UsageMetadata{

		PromptTokenCount: j.PromptTokenCount,

		CandidatesTokenCount: j.CandidatesTokenCount,

		TotalTokenCount: j.TotalTokenCount,
	}
}

// Helper functions to convert slices and maps
func FromCandidateSlice(src []*genai.Candidate) []*Candidate {
	if src == nil {
		return nil
	}
	dst := make([]*Candidate, len(src))
	for i, v := range src {
		dst[i] = FromCandidate(v)
	}
	return dst
}

func ToCandidateSlice(src []*Candidate) []*genai.Candidate {
	if src == nil {
		return nil
	}
	dst := make([]*genai.Candidate, len(src))
	for i, v := range src {
		dst[i] = v.To()
	}
	return dst
}

func FromContentSlice(src []*genai.Content) []*Content {
	if src == nil {
		return nil
	}
	dst := make([]*Content, len(src))
	for i, v := range src {
		dst[i] = FromContent(v) // Assumes FromContent exists and is correct
	}
	return dst
}

func ToContentSlice(src []*Content) []*genai.Content {
	if src == nil {
		return nil
	}
	dst := make([]*genai.Content, len(src))
	for i, v := range src {
		dst[i] = v.To() // Assumes To() method on Content exists and is correct
	}
	return dst
}

func FromSafetyRatingSlice(src []*genai.SafetyRating) []*SafetyRating {
	if src == nil {
		return nil
	}
	dst := make([]*SafetyRating, len(src))
	for i, v := range src {
		dst[i] = FromSafetyRating(v)
	}
	return dst
}

func ToSafetyRatingSlice(src []*SafetyRating) []*genai.SafetyRating {
	if src == nil {
		return nil
	}
	dst := make([]*genai.SafetyRating, len(src))
	for i, v := range src {
		dst[i] = v.To()
	}
	return dst
}

func FromCitationSlice(src []*genai.Citation) []*Citation {
	if src == nil {
		return nil
	}
	dst := make([]*Citation, len(src))
	for i, v := range src {
		dst[i] = FromCitation(v)
	}
	return dst
}

func ToCitationSlice(src []*Citation) []*genai.Citation {
	if src == nil {
		return nil
	}
	dst := make([]*genai.Citation, len(src))
	for i, v := range src {
		dst[i] = v.To()
	}
	return dst
}

// FromSchemaMap converts map[string]*genai.Schema to map[string]*Schema
func FromSchemaMap(src map[string]*genai.Schema) map[string]*Schema {
	if src == nil {
		return nil
	}
	dst := make(map[string]*Schema, len(src))
	for k, v := range src {
		dst[k] = FromSchema(v) // Assumes FromSchema exists and is correct
	}
	return dst
}

func ToSchemaMap(src map[string]*Schema) map[string]*genai.Schema {
	if src == nil {
		return nil
	}
	dst := make(map[string]*genai.Schema, len(src))
	for k, v := range src {
		dst[k] = v.To() // Assumes To() method on Schema exists and is correct
	}
	return dst
}

// FromToolSlice converts []*genai.Tool to []*Tool
func FromToolSlice(src []*genai.Tool) []*Tool {
	if src == nil {
		return nil
	}
	dst := make([]*Tool, len(src))
	for i, v := range src {
		dst[i] = FromTool(v) // Assumes FromTool exists and is correct
	}
	return dst
}

// ToToolSlice converts []*Tool to []*genai.Tool
func ToToolSlice(src []*Tool) []*genai.Tool {
	if src == nil {
		return nil
	}
	dst := make([]*genai.Tool, len(src))
	for i, v := range src {
		dst[i] = v.To() // Assumes To() method on Tool exists and is correct
	}
	return dst
}

// FromFunctionDeclarationSlice converts []*genai.FunctionDeclaration to []*FunctionDeclaration
func FromFunctionDeclarationSlice(src []*genai.FunctionDeclaration) []*FunctionDeclaration {
	if src == nil {
		return nil
	}
	dst := make([]*FunctionDeclaration, len(src))
	for i, v := range src {
		dst[i] = FromFunctionDeclaration(v) // Assumes FromFunctionDeclaration exists and is correct
	}
	return dst
}

// ToFunctionDeclarationSlice converts []*FunctionDeclaration to []*genai.FunctionDeclaration
func ToFunctionDeclarationSlice(src []*FunctionDeclaration) []*genai.FunctionDeclaration {
	if src == nil {
		return nil
	}
	dst := make([]*genai.FunctionDeclaration, len(src))
	for i, v := range src {
		dst[i] = v.To() // Assumes To() method on FunctionDeclaration exists and is correct
	}
	return dst
}

// Placeholder converters for enum pointers (add implementations as needed)
func fromFinishReasonPtr(src *genai.FinishReason) *FinishReason {
	if src == nil {
		return nil
	}
	v := FinishReason(*src)
	return &v
}
func fromHarmCategoryPtr(src *genai.HarmCategory) *HarmCategory {
	if src == nil {
		return nil
	}
	v := HarmCategory(*src)
	return &v
}
func fromHarmBlockThresholdPtr(src *genai.HarmBlockThreshold) *HarmBlockThreshold {
	if src == nil {
		return nil
	}
	v := HarmBlockThreshold(*src)
	return &v
}
func fromHarmProbabilityPtr(src *genai.HarmProbability) *HarmProbability {
	if src == nil {
		return nil
	}
	v := HarmProbability(*src)
	return &v
}
func fromHarmSeverityPtr(src *genai.HarmSeverity) *HarmSeverity {
	if src == nil {
		return nil
	}
	v := HarmSeverity(*src)
	return &v
}

func toFinishReasonPtr(src *FinishReason) *genai.FinishReason {
	if src == nil {
		return nil
	}
	v := genai.FinishReason(*src)
	return &v
}
func toHarmCategoryPtr(src *HarmCategory) *genai.HarmCategory {
	if src == nil {
		return nil
	}
	v := genai.HarmCategory(*src)
	return &v
}
func toHarmBlockThresholdPtr(src *HarmBlockThreshold) *genai.HarmBlockThreshold {
	if src == nil {
		return nil
	}
	v := genai.HarmBlockThreshold(*src)
	return &v
}
func toHarmProbabilityPtr(src *HarmProbability) *genai.HarmProbability {
	if src == nil {
		return nil
	}
	v := genai.HarmProbability(*src)
	return &v
}
func toHarmSeverityPtr(src *HarmSeverity) *genai.HarmSeverity {
	if src == nil {
		return nil
	}
	v := genai.HarmSeverity(*src)
	return &v
}
