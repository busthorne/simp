package main

const fileHeader = `
// Code generated by genvertex; DO NOT EDIT.
package vertexjson

import (
	"cloud.google.com/go/vertexai/genai"
	"cloud.google.com/go/civil"
	"time" // Needed for types like CachedContent and ExpireTimeOrTTL
	// Add necessary imports based on build errors
	// aiplatform "google.golang.org/genproto/googleapis/cloud/aiplatform/v1beta1" // Removed - Not used
	// "google.golang.org/protobuf/proto" // Removed - Not used
)
`

const enumTypes = `
// Define enum types to match genai package
type FinishReason int32 // Use underlying type
type FunctionCallingMode int32 // Use underlying type
type HarmCategory int32 // Use underlying type
type HarmBlockThreshold int32 // Use underlying type (Corrected from string)
type HarmProbability int32 // Use underlying type
type HarmSeverity int32 // Use underlying type
type Type int32
type BlockedReason int32 // Use underlying type
type HarmBlockMethod string // Keep as string for now unless errors show otherwise
`

const contentType = `
// Content struct that's referenced in multiple places
type Content struct {
	Role  string {{ tag "role" "" }}
	Parts []Part {{ tag "parts" "" }}
}

// FromContent converts from genai.Content to Content
func FromContent(src *genai.Content) *Content {
	if src == nil {
		return nil
	}
	return &Content{
		Role:  src.Role,
		Parts: FromPartSlice(src.Parts),
	}
}

// To converts to genai.Content
func (c *Content) To() *genai.Content {
	if c == nil {
		return nil
	}
	return &genai.Content{
		Role:  c.Role,
		Parts: ToPartSlice(c.Parts),
	}
}
`

const expireTimeType = `
// Helper type for ExpireTimeOrTTL which is a union type
type ExpireTimeOrTTL struct {
	// Only one of these should be set
	ExpireTime time.Time ` + "`json:\"expireTime,omitempty\"`" + `
	TTL time.Duration ` + "`json:\"ttl,omitempty\"`" + `
}

// FromExpireTimeOrTTL converts from genai.ExpireTimeOrTTL to ExpireTimeOrTTL
func FromExpireTimeOrTTL(src genai.ExpireTimeOrTTL) ExpireTimeOrTTL {
	var result ExpireTimeOrTTL

	if src.TTL != 0 {
		result.TTL = src.TTL
	} else if !src.ExpireTime.IsZero() {
		result.ExpireTime = src.ExpireTime
	}

	return result
}

// To converts to genai.ExpireTimeOrTTL
func (e ExpireTimeOrTTL) To() genai.ExpireTimeOrTTL {
	var result genai.ExpireTimeOrTTL

	if e.TTL != 0 {
		result.TTL = e.TTL
	} else if !e.ExpireTime.IsZero() {
		result.ExpireTime = e.ExpireTime
	}

	return result
}
`

const partTypes = `
// Part is an interface in genai, so we need custom types and handling
type Part struct {
	// Only one of these fields should be set
	Text string {{ tag "text" "" }}
	FunctionCall *FunctionCall {{ tag "functionCall" "" }}
	FunctionResponse *FunctionResponse {{ tag "functionResponse" "" }}
	FileData *FileData {{ tag "fileData" "" }}
	Blob *Blob {{ tag "blob" "" }}
}

// FromPart converts from genai.Part to Part
func FromPart(src genai.Part) Part {
	var p Part
	
	switch v := src.(type) {
	case genai.Text:
		p.Text = string(v)
	case *genai.FunctionCall:
		p.FunctionCall = FromFunctionCall(v)
	case *genai.FunctionResponse:
		p.FunctionResponse = FromFunctionResponse(v)
	case *genai.FileData:
		p.FileData = FromFileData(v)
	case *genai.Blob:
		p.Blob = FromBlob(v)
	}
	
	return p
}

// To converts to genai.Part
func (p Part) To() genai.Part {
	switch {
	case p.Text != "":
		return genai.Text(p.Text)
	case p.FunctionCall != nil:
		return p.FunctionCall.To()
	case p.FunctionResponse != nil:
		return p.FunctionResponse.To()
	case p.FileData != nil:
		return p.FileData.To()
	case p.Blob != nil:
		return p.Blob.To()
	default:
		// Return nil or an empty part? Returning nil might be problematic if the slice expects non-nil parts.
		// Let's return an empty Text part for now, consistent with original FromPart logic if no type matched.
		return genai.Text("")
	}
}

// FromPartSlice converts a slice of genai.Part to a slice of Part
func FromPartSlice(src []genai.Part) []Part {
	if src == nil {
		// Return nil instead of empty slice to distinguish between unset and empty
		return nil
	}
	result := make([]Part, len(src))
	for i, v := range src {
		result[i] = FromPart(v) // FromPart handles the conversion of individual Part types
	}
	return result
}

// ToPartSlice converts a slice of Part to a slice of genai.Part
func ToPartSlice(src []Part) []genai.Part {
	if src == nil {
		// Return nil instead of empty slice
		return nil
	}
	result := make([]genai.Part, len(src))
	for i, v := range src {
		result[i] = v.To() // v.To() handles the conversion back to genai.Part types
	}
	return result
}
`
const structDef = `
// {{.Name}} mirrors genai.{{.Name}} with JSON tags.
{{if .Comment}}// {{.Comment}}{{end}}
type {{.Name}} struct {
{{range .Fields}}	{{.Name}} {{.Type}} {{ tag .JSONName "" }} // Use target type (potentially unqualified)
{{end}}}

// From{{.Name}} converts from genai.{{.Name}} to {{.Name}}
func From{{.Name}}(src *genai.{{.Name}}) *{{.Name}} {
	if src == nil {
		return nil
	}
	return &{{.Name}}{
{{range .Fields}}{{/* Add specific type conversions based on ORIGINAL type (might be qualified or unqualified) */}}
{{/* Check for qualified first, then unqualified as fallback? Or just unqualified? Let's try unqualified based on logs */}}
{{if eq .OriginalType "[]Part"}}		{{.Name}}: FromPartSlice(src.{{.Name}}),
{{else if eq .OriginalType "*Schema"}}		{{.Name}}: FromSchema(src.{{.Name}}),
{{else if eq .OriginalType "map[string]*Schema"}}		{{.Name}}: FromSchemaMap(src.{{.Name}}),
{{else if eq .OriginalType "[]*FunctionDeclaration"}}		{{.Name}}: FromFunctionDeclarationSlice(src.{{.Name}}),
{{else if eq .OriginalType "[]*Tool"}}		{{.Name}}: FromToolSlice(src.{{.Name}}),
{{else if eq .OriginalType "[]*Content"}}		{{.Name}}: FromContentSlice(src.{{.Name}}),
{{else if eq .OriginalType "*Content"}}		{{.Name}}: FromContent(src.{{.Name}}),
{{else if eq .OriginalType "*ToolConfig"}}		{{.Name}}: FromToolConfig(src.{{.Name}}),
{{else if eq .OriginalType "[]*SafetyRating"}}		{{.Name}}: FromSafetyRatingSlice(src.{{.Name}}),
{{else if eq .OriginalType "[]*Citation"}}		{{.Name}}: FromCitationSlice(src.{{.Name}}),
{{else if eq .OriginalType "*CitationMetadata"}}		{{.Name}}: FromCitationMetadata(src.{{.Name}}),
{{else if eq .OriginalType "[]*Candidate"}}		{{.Name}}: FromCandidateSlice(src.{{.Name}}),
{{else if eq .OriginalType "*PromptFeedback"}}		{{.Name}}: FromPromptFeedback(src.{{.Name}}),
{{else if eq .OriginalType "*UsageMetadata"}}		{{.Name}}: FromUsageMetadata(src.{{.Name}}),
{{else if eq .OriginalType "*FunctionCallingConfig"}}		{{.Name}}: FromFunctionCallingConfig(src.{{.Name}}),
{{else if eq .OriginalType "ExpireTimeOrTTL"}}		{{.Name}}: FromExpireTimeOrTTL(src.{{.Name}}),
{{/* Handle enums */}}
{{else if eq .OriginalType "FinishReason"}}		{{.Name}}: FinishReason(src.{{.Name}}),
{{else if eq .OriginalType "FunctionCallingMode"}}		{{.Name}}: FunctionCallingMode(src.{{.Name}}),
{{else if eq .OriginalType "BlockedReason"}}		{{.Name}}: BlockedReason(src.{{.Name}}),
{{else if eq .OriginalType "HarmCategory"}}		{{.Name}}: HarmCategory(src.{{.Name}}),
{{else if eq .OriginalType "HarmProbability"}}		{{.Name}}: HarmProbability(src.{{.Name}}),
{{else if eq .OriginalType "HarmSeverity"}}		{{.Name}}: HarmSeverity(src.{{.Name}}),
{{else if eq .OriginalType "Type"}}		{{.Name}}: Type(src.{{.Name}}),
{{/* Handle potential pointer types for enums */}}
{{else if eq .OriginalType "*FinishReason"}}		{{.Name}}: fromFinishReasonPtr(src.{{.Name}}),
{{else if eq .OriginalType "*HarmCategory"}}		{{.Name}}: fromHarmCategoryPtr(src.{{.Name}}),
{{else if eq .OriginalType "*HarmBlockThreshold"}}		{{.Name}}: fromHarmBlockThresholdPtr(src.{{.Name}}),
{{else if eq .OriginalType "*HarmProbability"}}		{{.Name}}: fromHarmProbabilityPtr(src.{{.Name}}),
{{else if eq .OriginalType "*HarmSeverity"}}		{{.Name}}: fromHarmSeverityPtr(src.{{.Name}}),
{{/* Default: direct assignment ONLY for basic types assumed */}}
{{else}}		{{.Name}}: src.{{.Name}},
{{end}}{{end}}	}
}

// To converts to genai.{{.Name}}
func (j *{{.Name}}) To() *genai.{{.Name}} {
	if j == nil {
		return nil
	}
	return &genai.{{.Name}}{
{{range .Fields}}{{/* Add specific type conversions based on ORIGINAL type (might be qualified or unqualified) */}}
{{/* Check for qualified first, then unqualified as fallback? Or just unqualified? Let's try unqualified based on logs */}}
{{if eq .OriginalType "[]Part"}}		{{.Name}}: ToPartSlice(j.{{.Name}}),
{{else if eq .OriginalType "*Schema"}}		{{.Name}}: j.{{.Name}}.To(), // Assumes Schema has To() method
{{else if eq .OriginalType "map[string]*Schema"}}		{{.Name}}: ToSchemaMap(j.{{.Name}}),
{{else if eq .OriginalType "[]*FunctionDeclaration"}}		{{.Name}}: ToFunctionDeclarationSlice(j.{{.Name}}),
{{else if eq .OriginalType "[]*Tool"}}		{{.Name}}: ToToolSlice(j.{{.Name}}),
{{else if eq .OriginalType "[]*Content"}}		{{.Name}}: ToContentSlice(j.{{.Name}}),
{{else if eq .OriginalType "*Content"}}		{{.Name}}: j.{{.Name}}.To(), // Assumes Content has To() method
{{else if eq .OriginalType "*ToolConfig"}}		{{.Name}}: j.{{.Name}}.To(), // Assumes ToolConfig has To() method
{{else if eq .OriginalType "[]*SafetyRating"}}		{{.Name}}: ToSafetyRatingSlice(j.{{.Name}}),
{{else if eq .OriginalType "[]*Citation"}}		{{.Name}}: ToCitationSlice(j.{{.Name}}),
{{else if eq .OriginalType "*CitationMetadata"}}		{{.Name}}: j.{{.Name}}.To(), // Assumes CitationMetadata has To() method
{{else if eq .OriginalType "[]*Candidate"}}		{{.Name}}: ToCandidateSlice(j.{{.Name}}),
{{else if eq .OriginalType "*PromptFeedback"}}		{{.Name}}: j.{{.Name}}.To(), // Assumes PromptFeedback has To() method
{{else if eq .OriginalType "*UsageMetadata"}}		{{.Name}}: j.{{.Name}}.To(), // Assumes UsageMetadata has To() method
{{else if eq .OriginalType "*FunctionCallingConfig"}}		{{.Name}}: j.{{.Name}}.To(), // Assumes FunctionCallingConfig has To() method
{{else if eq .OriginalType "ExpireTimeOrTTL"}}		{{.Name}}: j.{{.Name}}.To(), // ExpireTimeOrTTL conversion
{{/* Handle enums */}}
{{else if eq .OriginalType "FinishReason"}}		{{.Name}}: genai.FinishReason(j.{{.Name}}),
{{else if eq .OriginalType "FunctionCallingMode"}}		{{.Name}}: genai.FunctionCallingMode(j.{{.Name}}),
{{else if eq .OriginalType "BlockedReason"}}		{{.Name}}: genai.BlockedReason(j.{{.Name}}),
{{else if eq .OriginalType "HarmCategory"}}		{{.Name}}: genai.HarmCategory(j.{{.Name}}),
{{else if eq .OriginalType "HarmProbability"}}		{{.Name}}: genai.HarmProbability(j.{{.Name}}),
{{else if eq .OriginalType "HarmSeverity"}}		{{.Name}}: genai.HarmSeverity(j.{{.Name}}),
{{else if eq .OriginalType "Type"}}		{{.Name}}: genai.Type(j.{{.Name}}),
{{/* Handle potential pointer types for enums */}}
{{else if eq .OriginalType "*FinishReason"}}		{{.Name}}: toFinishReasonPtr(j.{{.Name}}),
{{else if eq .OriginalType "*HarmCategory"}}		{{.Name}}: toHarmCategoryPtr(j.{{.Name}}),
{{else if eq .OriginalType "*HarmBlockThreshold"}}		{{.Name}}: toHarmBlockThresholdPtr(j.{{.Name}}),
{{else if eq .OriginalType "*HarmProbability"}}		{{.Name}}: toHarmProbabilityPtr(j.{{.Name}}),
{{else if eq .OriginalType "*HarmSeverity"}}		{{.Name}}: toHarmSeverityPtr(j.{{.Name}}),
{{/* Default: direct assignment ONLY for basic types assumed */}}
{{else}}		{{.Name}}: j.{{.Name}},
{{end}}{{end}}	}
}
`
const helperFunctions = `
// Helper functions to convert slices and maps
func FromCandidateSlice(src []*genai.Candidate) []*Candidate {
	if src == nil {
		return nil
	}
	dst := make([]*Candidate, len(src))
	for i, v := range src {
		dst[i] = FromCandidate(v)
	}
	return dst
}

func ToCandidateSlice(src []*Candidate) []*genai.Candidate {
	if src == nil {
		return nil
	}
	dst := make([]*genai.Candidate, len(src))
	for i, v := range src {
		dst[i] = v.To()
	}
	return dst
}

func FromContentSlice(src []*genai.Content) []*Content {
	if src == nil {
		return nil
	}
	dst := make([]*Content, len(src))
	for i, v := range src {
		dst[i] = FromContent(v) // Assumes FromContent exists and is correct
	}
	return dst
}

func ToContentSlice(src []*Content) []*genai.Content {
	if src == nil {
		return nil
	}
	dst := make([]*genai.Content, len(src))
	for i, v := range src {
		dst[i] = v.To() // Assumes To() method on Content exists and is correct
	}
	return dst
}

func FromSafetyRatingSlice(src []*genai.SafetyRating) []*SafetyRating {
	if src == nil {
		return nil
	}
	dst := make([]*SafetyRating, len(src))
	for i, v := range src {
		dst[i] = FromSafetyRating(v)
	}
	return dst
}

func ToSafetyRatingSlice(src []*SafetyRating) []*genai.SafetyRating {
	if src == nil {
		return nil
	}
	dst := make([]*genai.SafetyRating, len(src))
	for i, v := range src {
		dst[i] = v.To()
	}
	return dst
}

func FromCitationSlice(src []*genai.Citation) []*Citation {
	if src == nil {
		return nil
	}
	dst := make([]*Citation, len(src))
	for i, v := range src {
		dst[i] = FromCitation(v)
	}
	return dst
}

func ToCitationSlice(src []*Citation) []*genai.Citation {
	if src == nil {
		return nil
	}
	dst := make([]*genai.Citation, len(src))
	for i, v := range src {
		dst[i] = v.To()
	}
	return dst
}

// FromSchemaMap converts map[string]*genai.Schema to map[string]*Schema
func FromSchemaMap(src map[string]*genai.Schema) map[string]*Schema {
	if src == nil {
		return nil
	}
	dst := make(map[string]*Schema, len(src))
	for k, v := range src {
		dst[k] = FromSchema(v) // Assumes FromSchema exists and is correct
	}
	return dst
}

func ToSchemaMap(src map[string]*Schema) map[string]*genai.Schema {
	if src == nil {
		return nil
	}
	dst := make(map[string]*genai.Schema, len(src))
	for k, v := range src {
		dst[k] = v.To() // Assumes To() method on Schema exists and is correct
	}
	return dst
}

// FromToolSlice converts []*genai.Tool to []*Tool
func FromToolSlice(src []*genai.Tool) []*Tool {
	if src == nil {
		return nil
	}
	dst := make([]*Tool, len(src))
	for i, v := range src {
		dst[i] = FromTool(v) // Assumes FromTool exists and is correct
	}
	return dst
}

// ToToolSlice converts []*Tool to []*genai.Tool
func ToToolSlice(src []*Tool) []*genai.Tool {
	if src == nil {
		return nil
	}
	dst := make([]*genai.Tool, len(src))
	for i, v := range src {
		dst[i] = v.To() // Assumes To() method on Tool exists and is correct
	}
	return dst
}

// FromFunctionDeclarationSlice converts []*genai.FunctionDeclaration to []*FunctionDeclaration
func FromFunctionDeclarationSlice(src []*genai.FunctionDeclaration) []*FunctionDeclaration {
	if src == nil {
		return nil
	}
	dst := make([]*FunctionDeclaration, len(src))
	for i, v := range src {
		dst[i] = FromFunctionDeclaration(v) // Assumes FromFunctionDeclaration exists and is correct
	}
	return dst
}

// ToFunctionDeclarationSlice converts []*FunctionDeclaration to []*genai.FunctionDeclaration
func ToFunctionDeclarationSlice(src []*FunctionDeclaration) []*genai.FunctionDeclaration {
	if src == nil {
		return nil
	}
	dst := make([]*genai.FunctionDeclaration, len(src))
	for i, v := range src {
		dst[i] = v.To() // Assumes To() method on FunctionDeclaration exists and is correct
	}
	return dst
}

// Placeholder converters for enum pointers (add implementations as needed)
func fromFinishReasonPtr(src *genai.FinishReason) *FinishReason { if src == nil { return nil }; v := FinishReason(*src); return &v }
func fromHarmCategoryPtr(src *genai.HarmCategory) *HarmCategory { if src == nil { return nil }; v := HarmCategory(*src); return &v }
func fromHarmBlockThresholdPtr(src *genai.HarmBlockThreshold) *HarmBlockThreshold { if src == nil { return nil }; v := HarmBlockThreshold(*src); return &v }
func fromHarmProbabilityPtr(src *genai.HarmProbability) *HarmProbability { if src == nil { return nil }; v := HarmProbability(*src); return &v }
func fromHarmSeverityPtr(src *genai.HarmSeverity) *HarmSeverity { if src == nil { return nil }; v := HarmSeverity(*src); return &v }

func toFinishReasonPtr(src *FinishReason) *genai.FinishReason { if src == nil { return nil }; v := genai.FinishReason(*src); return &v }
func toHarmCategoryPtr(src *HarmCategory) *genai.HarmCategory { if src == nil { return nil }; v := genai.HarmCategory(*src); return &v }
func toHarmBlockThresholdPtr(src *HarmBlockThreshold) *genai.HarmBlockThreshold { if src == nil { return nil }; v := genai.HarmBlockThreshold(*src); return &v }
func toHarmProbabilityPtr(src *HarmProbability) *genai.HarmProbability { if src == nil { return nil }; v := genai.HarmProbability(*src); return &v }
func toHarmSeverityPtr(src *HarmSeverity) *genai.HarmSeverity { if src == nil { return nil }; v := genai.HarmSeverity(*src); return &v }

`
